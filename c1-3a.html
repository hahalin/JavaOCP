Chapter 1: Welcome to Java
B, E. C++ has operator overloading and pointers. Java made a point of not having either. Java does have references to objects, but these are pointing to an object that can move around in memory. Option B is correct because Java is platform independent. Option E is correct because Java is object-oriented. While it does support some parts of functional programming, these occur within a class.
C, D. Java puts source code in .java files and bytecode in .class files. It does not use a .bytecode file. When running a Java program, you pass just the name of the class without the .class extension.
C, D. This example is using the single-file source-code launcher. It compiles in memory rather than creating a .class file, making option A incorrect. To use this launcher, programs can only reference classes built into the JDK. Therefore, option B is incorrect, and options C and D are correct.
C, D. The Tank class is there to throw you off since it isn’t used by AquariumVisitor. Option C is correct because it imports Jelly by class name. Option D is correct because it imports all the classes in the jellies package, which includes Jelly. Option A is incorrect because it only imports classes in the aquarium package—Tank in this case—and not those in lower-level packages. Option B is incorrect because you cannot use wildcards anywhere other than the end of an import statement. Option E is incorrect because you cannot import parts of a class with a regular import statement. Option F is incorrect because options C and D do make the code compile.
A, C, D, E. Eclipse is an integrated development environment (IDE). It is not included in the Java Development Kit (JDK), making option B incorrect. The JDK comes with a number of command-line tools including a compiler, packager, and documentation, making options A, D, and E correct. The JDK also includes the Java Virtual Machine (JVM), making option C correct.
E. The first two imports can be removed because java.lang is automatically imported. The following two imports can be removed because Tank and Water are in the same package, making the correct option E. If Tank and Water were in different packages, exactly one of these two imports could be removed. In that case, the answer would be option D.
A, B, C. Option A is correct because it imports all the classes in the aquarium package including aquarium.Water. Options B and C are correct because they import Water by class name. Since importing by class name takes precedence over wildcards, these compile. Option D is incorrect because Java doesn’t know which of the two wildcard Water classes to use. Option E is incorrect because you cannot specify the same class name in two imports.
A, B. The wildcard is configured for files ending in .java, making options E and F incorrect. Additionally, wildcards aren’t recursive, making options C and D incorrect. Therefore, options A and B are correct.
B. Option B is correct because arrays start counting from zero and strings with spaces must be in quotes. Option A is incorrect because it outputs Blue. C is incorrect because it outputs Jay. Option D is incorrect because it outputs Sparrow. Options E and F are incorrect because they output java.lang.ClassNotFoundException: BirdDisplay .class.
E. Option E is the canonical main() method signature. You need to memorize it. Option A is incorrect because the main() method must be public. Options B and F are incorrect because the main() method must have a void return type. Option C is incorrect because the main() method must be static. Option D is incorrect because the main() method must be named main.
C, D. While we wish it were possible to guarantee bug-free code, this is not something a language can ensure, making option A incorrect. Deprecation is an indication that other code should be preferred. It doesn’t preclude or require eventual removal, making option B incorrect. Option E is incorrect because backward compatibility is a design goal, not sideways compatibility. Options C and D are correct.
C, E. When compiling with javac, you can specify a classpath with -cp or a directory with -d, making options C and E correct. Since the options are case sensitive, option D is incorrect. The other options are not valid on the javac command.
C. When running a program using java, you specify the classpath with -cp, making option C correct. Options D and F are incorrect because -d and -p are used for modules. Options A and B are not valid options on the java command.
A, B, C, E. When creating a jar file, you use the options -cf or -cvf, making options A and E correct. The jar command allows the use of the classpath, making option C correct. It also allows the specification of a directory using -C, making option B correct. Options D and F are incorrect because -d and -p are used for modules.
E. The main() method isn’t static. It is a method that happens to be named main(), but it’s not an application entry point. When the program is run, it gives the error. If the method were static, the answer would be option D. Arrays are zero-based, so the loop ignores the first element and throws an exception when accessing the element after the last one.
D. The package name represents any folders underneath the current path, which is named.A in this case. Option C is incorrect because package names are case sensitive, just like variable names and other identifiers.
A, E. Bunny is a class, which can be seen from the declaration: public class Bunny. The variable bun is a reference to an object. The method main() is the standard entry point to a program. Option G is incorrect because the parameter type matters, not the parameter name.
C, D, E. The package and import statements are both optional. If both are present, the order must be package, then import, and then class. Option A is incorrect because class is before package and import. Option B is incorrect because import is before package. Option F is incorrect because class is before package.
B, C. Eclipse is an integrated development environment (IDE). It is available from the Eclipse Foundation, not from Oracle, making option C one of the answers. The other answer is option B because the Java Development Kit (JDK) is what you download to get started. The Java Runtime Environment (JRE) was an option for older versions of Java, but it’s no longer a download option for Java 11.
A, B, E. Unfortunately, this is something you have to memorize. The code with the hyphenated word class-path uses two dashes in front, making option E correct and option D incorrect. The reverse is true for the unhyphenated classpath, making option B correct and option C incorrect. Finally, the short form is option A.
Chapter 2: Java Building Blocks
B, E, G. Option A is invalid because a single underscore is no longer allowed as an identifier as of Java 9. Option B is valid because you can use an underscore within identifiers, and a dollar sign ($) is also a valid character. Option C is not a valid identifier because true is a Java reserved word. Option D is not valid because a period (.) is not allowed in identifiers. Option E is valid because Java is case sensitive. Since Public is not a reserved word, it is allowed as an identifier, whereas public would not be allowed. Option F is not valid because the first character is not a letter, dollar sign ($), or underscore (_). Finally, option G is valid as identifiers can contain underscores (_) and numbers, provided the number does not start the identifier.
D, F, G. The code compiles and runs without issue, so options A and B are incorrect. A boolean field initializes to false, making option D correct with Empty = false being printed. Object references initialize to null, not the empty String, so option F is correct with Brand = null being printed. Finally, the default value of floating-point numbers is 0.0. Although float values can be declared with an f suffix, they are not printed with an f suffix. For these reasons, option G is correct and Code = 0.0 is printed.
B, D, E, H. A var cannot be initialized with a null value without a type, but it can be assigned a null value if the underlying type is not a primitive. For these reasons, option H is correct, but options A and C are incorrect. Options B and D are correct as the underlying types are String and Object, respectively. Option E is correct, as this is a valid numeric expression. You might know that dividing by zero produces a runtime exception, but the question was only about whether the code compiled. Finally, options F and G are incorrect as var cannot be used in a multiple-variable assignment.
A, B, D, E. Line 4 does not compile because the L suffix makes the literal value a long, which cannot be stored inside a short directly, making option A correct. Line 5 does not compile because int is an integral type, but 2.0 is a double literal value, making option B correct. Line 6 compiles without issue. Lines 7 and 8 do not compile because numPets and numGrains are both primitives, and you can call methods only on reference types, not primitive values, making options D and E correct, respectively. Finally, line 9 compiles because there is a length() method defined on String.
A, D. The class does not compile, so options E, F, G, and H are incorrect. You might notice things like loops and increment/decrement operators in this problem, which we will cover in the next two chapters, but understanding them is not required to answer this question. The first compiler error is on line 3. The variable temp is declared as a float, but the assigned value is 50.0, which is a double without the F/f postfix. Since a double doesn’t fit inside a float, line 3 does not compile. Next, depth is declared inside the for loop and only has scope inside this loop. Therefore, reading the value on line 10 triggers a compiler error. Note that the variable Depth on line 2 is never used. Java is case sensitive, so Depth and depth are distinct variables. For these reasons, options A and D are the correct answers.
C, E. Option C is correct because float and double primitives default to 0.0, which also makes option A incorrect. Option E is correct because all nonprimitive values default to null, which makes option F incorrect. Option D is incorrect because int primitives default to 0. Option B is incorrect because char defaults to the NUL character, '\u0000'. You don’t need to know this value for the exam, but you should know the default value is not null since it is a primitive.
G. Option G is correct because local variables do not get assigned default values. The code fails to compile if a local variable is used when not being explicitly initialized. If this question were about instance variables, options B, D, and E would be correct. A boolean primitive defaults to false, and a float primitive defaults to 0.0f.
B, E. Option B is correct because boolean primitives default to false. Option E is correct because long values default to 0L.
C, E, F. In Java, there are no guarantees when garbage collection will run. The JVM is free to ignore calls to System.gc(). For this reason, options A, B, and D are incorrect. Option C is correct, as the purpose of garbage collection is to reclaim used memory. Option E is also correct that an object may never be garbage collected, such as if the program ends before garbage collection runs. Option F is correct and is the primary means by which garbage collection algorithms determine whether an object is eligible for garbage collection. Finally, option G is incorrect as marking a variable final means it is constant within its own scope. For example, a local variable marked final will be eligible for garbage collection after the method ends, assuming there are no other references to the object that exist outside the method.
C. The class does compiles without issue, so options E, F, and G are incorrect. The key thing to notice is line 4 does not define a constructor, but instead a method named PoliceBox(), since it has a return type of void. This method is never executed during the program run, and color and age get assigned the default values null and 0L, respectively. Lines 11 and 12 change the values for an object associated with p, but then on line 13 the p variable is changed to point to the object associated with q, which still has the default values. For this reason, the program prints Q1=null, Q2=0, P1=null, and P2=0, making option C the only correct answer.
A, D, E. From Chapter 1, a main() method must have a valid identifier of type String... or String[]. For this reason, option G can be eliminated immediately. Option A is correct because var is not a reserved word in Java and may be used as an identifier. Option B is incorrect as a period (.) may not be used in an identifier. Option C is also incorrect as an identifier may include digits but not start with one. Options D and E are correct as an underscore (_) and dollar sign ($) may appear anywhere in an identifier. Finally, option F is incorrect, as a var may not be used as a method argument.
A, E, F. An underscore (_) can be placed in any numeric literal, so long as it is not at the beginning, the end, or next to a decimal point (.). Underscores can even be placed next to each other. For these reasons, options A, E, and F are correct. Options B and D are incorrect, as the underscore (_) is next to a decimal point (.). Options C and G are incorrect, because an underscore (_) cannot be placed at the beginning or end of the literal.
B, D, H. The Rabbit object from line 3 has two references to it: one and three. The references are set to null on lines 6 and 8, respectively. Option B is correct because this makes the object eligible for garbage collection after line 8. Line 7 sets the reference four to null, since that is the value of one, which means it has no effect on garbage collection. The Rabbit object from line 4 has only a single reference to it: two. Option D is correct because this single reference becomes null on line 9. The Rabbit object declared on line 10 becomes eligible for garbage collection at the end of the method on line 12, making option H correct. Calling System.gc() has no effect on eligibility for garbage collection.
B, C, F. A var cannot be used for a constructor or method parameter or for an instance or class variable, making option A incorrect and option C correct. The type of var is known at compile-time and the type cannot be changed at runtime, although its value can change at runtime. For these reasons, options B and F are correct, and option E is incorrect. Option D is incorrect, as var is not permitted in multiple-variable declarations. Finally, option G is incorrect, as var is not a reserved word in Java.
C, F, G. First off, 0b is the prefix for a binary value, and 0x is the prefix for a hexadecimal value. These values can be assigned to many primitive types, including int and double, making options C and F correct. Option A is incorrect because naming the variable Amount will cause the System.out.print(amount) call on the next line to not compile. Option B is incorrect because 9L is a long value. If the type was changed to long amount = 9L, then it would compile. Option D is incorrect because 1_2.0 is a double value. If the type was changed to double amount = 1_2.0, then it would compile. Options E and H are incorrect because the underscore (_) appears next to the decimal point (.), which is not allowed. Finally, option G is correct and the underscore and assignment usage is valid.
A, C, D. The code contains three compilation errors, so options E, F, G, and H are incorrect. Line 2 does not compile, as this is incorrect syntax for declaring multiple variables, making option A correct. The data type is declared only once and shared among all variables in a multiple variable declaration. Line 3 compiles without issue, as it declares a local variable inside an instance initializer that is never used. Line 4 does not compile because Java, unlike some other programming languages, does not support setting default method parameter values, making option C correct. Finally, line 7 does not compile because fins is in scope and accessible only inside the instance initializer on line 3, making option D correct.
A, E, F, G. The question is primarily about variable scope. A variable defined in a statement such as a loop or initializer block is accessible only inside that statement. For this reason, options A and E are correct. Option B is incorrect because variables can be defined inside initializer blocks. Option C is incorrect, as a constructor argument is accessible only in the constructor itself, not for the life of the instance of the class. Constructors and instance methods can access any instance variable, even ones defined after their declaration, making option D incorrect and options F and G correct.
F, G. The code does not compile, so options A, B, C, and D are all incorrect. The first compilation error occurs on line 5. Since char is an unsigned data type, it cannot be assigned a negative value, making option F correct. The second compilation error is on line 9, since mouse is used without being initialized, making option G correct. You could fix this by initializing a value on line 4, but the compiler reports the error where the variable is used, not where it is declared.
F. To solve this problem, you need to trace the braces {} and see when variables go in and out of scope. You are not required to understand the various data structures in the question, as this will be covered in the next few chapters. We start with hairs, which goes in and out of scope on line 2, as it is declared in an instance initializer, so it is not in scope on line 14. The three variables—water, air, twoHumps, declared on lines 3 and 4—are instance variables, so all three are in scope in all instance methods of the class, including spit() and on line 14. The distance method parameter is in scope for the life of the spit() method, making it the fourth value in scope on line 14. The path variable is in scope on line 6 and stays in scope until the end of the method on line 16, making it the fifth variable in scope on line 14. The teeth variable is in scope on line 7 and immediately goes out of scope on line 7 since the statement ends. The two variables age and i defined on lines 9 and 10, respectively, both stay in scope until the end of the while loop on line 15, bringing the total variables in scope to seven on line 14. Finally, Private is in scope on 12 but out of scope after the for loop ends on line 13. Since the total in-scope variables is seven, option F is the correct answer.
D. The class compiles and runs without issue, so options F and G are incorrect. We start with the main() method, which prints 7- on line 11. Next, a new Salmon instance is created on line 11. This calls the two instance initializers on lines 3 and 4 to be executed in order. The default value of an instance variable of type int is 0, so 0- is printed next and count is assigned a value of 1. Next, the constructor is called. This assigns a value of 4 to count and prints 2-. Finally, line 12 prints 4-, since that is the value of count. Putting it altogether, we have 7-0-2-4-, making option D the correct answer.
A, D, F. The class compiles and runs without issue, so option H is incorrect. The program creates two Bear objects, one on line 9 and one on line 10. The first Bear object is accessible until line 13 via the brownBear reference variable. The second Bear object is passed to the first object’s roar() method on line 11, meaning it is accessible via both the polarBear reference and the brownBear.pandaBear reference. After line 12, the object is still accessible via brownBear.pandaBear. After line 13, though, it is no longer accessible since brownBear is no longer accessible. In other words, both objects become eligible for garbage collection after line 13, making options A and D correct. Finally, garbage collection is never guaranteed to run or not run, since the JVM decides this for you. For this reason, option F is correct, and options E and G are incorrect. The class contains a finalize() method, although this does not contribute to the answer. For the exam, you may see finalize() in a question, but since it’s deprecated as of Java 9, you will not be tested on it.
H. None of these declarations is a valid instance variable declaration, as var cannot be used with instance variables, only local variables. For this reason, option H is the only correct answer. If the question were changed to be about local variable declarations, though, then the correct answers would be options C, D, and E. An identifier must start with a letter, $, or _, so options F and G would be incorrect. As of Java 9, a single underscore is not allowed as an identifier, so option A would be incorrect. Options A and G would also be incorrect because their numeric expressions use underscores incorrectly. An underscore cannot appear at the end of literal value, nor next to a decimal point (.). Finally, null is a reserved word, but var is not, so option B would be incorrect, and option E would be correct.
Chapter 3: Operators
A, D, G. Option A is the equality operator and can be used on primitives and object references. Options B and C are both arithmetic operators and cannot be applied to a boolean value. Option D is the logical complement operator and is used exclusively with boolean values. Option E is the modulus operator, which can be used only with numeric primitives. Option F is a relational operator that compares the values of two numbers. Finally, option G is correct, as you can cast a boolean variable since boolean is a type.
A, B, D. The expression apples + oranges is automatically promoted to int, so int and data types that can be promoted automatically from int will work. Options A, B, and D are such data types. Option C will not work because boolean is not a numeric data type. Options E and F will not work without an explicit cast to a smaller data type.
B, C, D, F. The code will not compile as is, so option A is not correct. The value 2 * ear is automatically promoted to long and cannot be automatically stored in hearing, which is in an int value. Options B, C, and D solve this problem by reducing the long value to int. Option E does not solve the problem and actually makes it worse by attempting to place the value in a smaller data type. Option F solves the problem by increasing the data type of the assignment so that long is allowed.
B. The code compiles and runs without issue, so option E is not correct. This example is tricky because of the second assignment operator embedded in line 5. The expression (wolf=false) assigns the value false to wolf and returns false for the entire expression. Since teeth does not equal 10, the left side returns true; therefore, the exclusive or (^) of the entire expression assigned to canine is true. The output reflects these assignments, with no change to teeth, so option B is the only correct answer.
A, C. Options A and C show operators in increasing or the same order of precedence. Options B and E are in decreasing or the same order of precedence. Options D, F, and G are in neither increasing or decreasing order of precedence. In option D, the assignment operator (=) is between two unary operators, with the multiplication operator (*) incorrectly having the highest order or precedence. In option F, the logical complement operator (!) has the highest order of precedence, so it should be last. In option G, the assignment operators have the lowest order of precedence, not the highest, so the last two operators should be first.
F. The code does not compile because line 3 contains a compilation error. The cast (int) is applied to fruit, not the expression fruit+vegetables. Since the cast operator has a higher operator precedence than the addition operator, it is applied to fruit, but the expression is promoted to a float, due to vegetables being float. The result cannot be returned as long in the addCandy() method without a cast. For this reason, option F is correct. If parentheses were added around fruit+vegetables, then the output would be 3-5-6, and option B would be correct. Remember that casting floating point numbers to integral values results in truncation, not rounding.
D. In the first boolean expression, vis is 2 and ph is 7, so this expression evaluates to true & (true || false), which reduces to true. The second boolean expression uses the short-circuit operator, and since (vis > 2) is false, the right side is not evaluated, leaving ph at 7. In the last assignment, ph is 7, and the pre-decrement operator is applied first, reducing the expression to 7 <= 6 and resulting in an assignment of false. For these reasons, option D is the correct answer.
A. The code compiles and runs without issue, so option E is incorrect. Line 7 does not produce a compilation error since the compound operator applies casting automatically. Line 5 increments pig by 1, but it returns the original value of 4 since it is using the post-increment operator. The pig variable is then assigned this value, and the increment operation is discarded. Line 7 just reduces the value of goat by 1, resulting in an output of 4 - 1 and making option A the correct answer.
A, D, E. The code compiles without issue, so option G is incorrect. In the first expression, a > 2 is false, so b is incremented to 5 but since the post-increment operator is used, 4 is printed, making option D correct. The --c was not applied, because only one right side of the ternary expression was evaluated. In the second expression, a!=c is false since c was never modified. Since b is 5 due to the previous line and the post-increment operator is used, b++ returns 5. The result is then assigned to b using the assignment operator, overriding the incremented value for b and printing 5, making option E correct. In the last expression, parentheses are not required but lack of parentheses can make ternary expressions difficult to read. From the previous lines, a is 2, b is 5, and c is 2. We can rewrite this expression with parentheses as (2 > 5 ? (5 < 2 ? 5 : 2) : 1). The second ternary expression is never evaluated since 2 > 5 is false, and the expression returns 1, making option A correct.
G. The code does not compile due to an error on the second line. Even though both height and weight are cast to byte, the multiplication operator automatically promotes them to int, resulting in an attempt to store an int in a short variable. For this reason, the code does not compile, and option G is the only correct answer. This line contains the only compilation error. If the code were corrected to add parentheses around the entire expression and cast it to a byte or short, then the program would print 3, 6, and 2 in that order.
D. First off, the * and % have the same operator precedence, so the expression is evaluated from left to right unless parentheses are present. The first expression evaluates to 8 % 3, which leaves a remainder of 2. The second expression is just evaluated left to right since * and % have the same operator precedence, and it reduces to 6 % 3, which is 0. The last expression reduces to 5 * 1, which is 5. Therefore, the output on line 6 is 2-0-5, making option D the correct answer.
D. The pre- prefix indicates the operation is applied first, and the new value is returned, while the post- prefix indicates the original value is returned prior to the operation. Next, increment increases the value, while decrement decreases the value. For these reasons, option D is the correct answer.
F. The first expression is evaluated from left to right since the operator precedence of & and ^ is the same, letting us reduce it to false ^ sunday, which is true, because sunday is true. In the second expression, we apply the negation operator, (!), first, reducing the expression to sunday && true, which evaluates to true. In the last expression, both variables are true so they reduce to !(true && true), which further reduces to !true, aka false. For these reasons, option F is the correct answer.
B, E, G. The return value of an assignment operation in the expression is the same as the value of the newly assigned variable. For this reason, option A is incorrect, and option E is correct. Option B is correct, and the equality (==) and inequality (!=) operators can both be used with objects. Option C is incorrect, as boolean and numeric types are not comparable with each other. For example, you can’t say true == 3 without a compilation error. Option D is incorrect, as only the short-circuit operator (&&) may cause only the left side of the expression to be evaluated. The (|) operator will cause both sides to be evaluated. Option F is incorrect, as Java does not accept numbers for boolean values. Finally, option G is correct, as you need to use the negation operator (-) to flip or negate numeric values, not the logical complement operator (!).
D. The ternary operator is the only operator that takes three values, making option D the only correct choice. Options A, B, C, E, and G are all binary operators. While they can be strung together in longer expressions, each operation uses only two values at a time. Option F is a unary operator and takes only one value.
B. The first line contains a compilation error. The value 3 is cast to long. The 1 * 2 value is evaluated as int but promoted to long when added to the 3. Trying to store a long value in an int variable triggers a compiler error. The other lines do not contain any compilation errors, as they store smaller values in larger or same-size data types, with the third and fourth lines using casting to do so.
C, F. The starting values of ticketsTaken and ticketsSold are 1 and 3, respectively. After the first compound assignment, ticketsTaken is incremented to 2. The ticketsSold value is increased from 3 to 5; since the post-increment operator was used the value of ticketsTaken++ returns 1. On the next line, ticketsTaken is doubled to 4. On the final line, ticketsSold is increased by 1 to 6. The final values of the variables are 4 and 6, for ticketsTaken and ticketsSold, respectively, making options C and F the correct answers. Note the last line does not trigger a compilation error as the compound operator automatically casts the right-hand operand.
C. Only parentheses, ( ), can be used to change the order of operation in an expression. The other operators, such as [ ], < >, and { }, cannot be used as parentheses in Java.
B, F. The code compiles and runs successfully, so options G and H are incorrect. On line 5, the pre-increment operator is executed first, so start is incremented to 8, and the new value is returned as the right side of the expression. The value of end is computed by adding 8 to the original value of 4, leaving a new value of 12 for end, and making option F a correct answer. On line 6, we are incrementing one past the maximum byte value. Due to overflow, this will result in a negative number, making option B the correct answer. Even if you didn’t know the maximum value of byte, you should have known the code compiles and runs and looked for the answer for start with a negative number.
A, D, E. Unary operators have the highest order of precedence, making option A correct. The negation operator (-) is used only for numeric values, while the logical complement operator (!) is used exclusively for boolean values. For these reasons, option B is incorrect, and option E is correct. Finally, the pre-increment/pre-decrement operators return the new value of the variable, while the post-increment/post-decrement operators return the original variable. For these reasons, option C is incorrect, and option D is correct.
